"""
dd-trace-py interaction layer.
"""

import contextlib
import logging

from ddtestopt.utils import TestContext
from ddtestopt.utils import _gen_item_id
from ddtestopt.utils import DDTESTOPT_ROOT_SPAN_RESOURCE

log = logging.getLogger(__name__)


def install_global_trace_filter(writer):
    """
    Install a trace filter in the global ddtrace tracer that forwards spans generated by ddtrace to ddtestopt.
    """
    try:
        import ddtrace  # noqa: F401
    except ImportError:
        log.debug("ddrace is not available, not installing trace filter")
        return None

    from .span_processor import TestOptSpanProcessor

    try:
        ddtrace.tracer.configure(trace_processors=[TestOptSpanProcessor(writer)])
    except TypeError:
        # ddtrace 2.x compatibility
        ddtrace.tracer.configure(settings={"FILTERS": [TestOptSpanProcessor(writer)]})

    # TODO: this should be somewhere else, and should not be specific to flask.
    ddtrace.patch(flask=True)


def uninstall_global_trace_filter():
    """
    Uninstall trace filters from the global ddtrace tracer.
    """
    try:
        import ddtrace
    except ImportError:
        return None

    try:
        ddtrace.tracer.configure(trace_processors=[])
    except TypeError:
        # ddtrace 2.x compatibility
        ddtrace.tracer.configure(settings={"FILTERS": []})


def trace_context(ddtrace_enabled: bool):
    """
    Create a trace context for a test to run.

    If ddtrace is enabled, a ddtrace context will be started; any spans created inside the test (e.g., instrumented HTTP
    requests) will be children of this context. This context manager yields a `TestContext` object containing the
    trace_id and span_id of created context.

    If ddtrace is not enabled, yields a dummy context with a freshly generated trace_id and span_id.
    """
    if ddtrace_enabled:
        try:
            import ddtrace  # noqa: F401

            return _ddtrace_context()
        except ImportError:
            log.debug("ddrace is not available, falling back to non-ddtrace context")

    return _plain_context()


@contextlib.contextmanager
def _ddtrace_context():
    import ddtrace

    # TODO: check if this breaks async tests.
    # This seems to be necessary because buggy ddtrace integrations can leave spans
    # unfinished, and spans for subsequent tests will have the wrong parent.
    ddtrace.tracer.context_provider.activate(None)

    with ddtrace.tracer.trace(DDTESTOPT_ROOT_SPAN_RESOURCE) as root_span:
        yield TestContext(trace_id=root_span.trace_id % (1 << 64), span_id=root_span.span_id % (1 << 64))


@contextlib.contextmanager
def _plain_context():
    yield TestContext(trace_id=_gen_item_id(), span_id=_gen_item_id())
