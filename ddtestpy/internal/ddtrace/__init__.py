"""
dd-trace-py interaction layer.
"""

import contextlib
import logging
import typing as t

from ddtestpy.ddtrace_interface import tracer_interface_instance
from ddtestpy.internal.utils import DDTESTOPT_ROOT_SPAN_RESOURCE
from ddtestpy.internal.utils import TestContext
from ddtestpy.internal.utils import _gen_item_id
from ddtestpy.internal.writer import Event
from ddtestpy.internal.writer import TestOptWriter


log = logging.getLogger(__name__)


def install_global_trace_filter(writer: TestOptWriter) -> None:
    """
    Install a trace filter in the global ddtrace tracer that forwards spans generated by ddtrace to ddtestpy.
    """
    if not tracer_interface_instance:
        log.warning("No ddtrace interface detected, --ddtrace-patch-all functionality will be disabled")
        return

    def push_span(
        trace_id: int,
        parent_id: t.Optional[int],
        span_id: int,
        service: str,
        resource: str,
        name: str,
        error: int,
        start_ns: int,
        duration_ns: int,
        meta: t.Dict[str, str],
        metrics: t.Dict[str, float],
        span_type: str,
    ) -> None:
        if resource == DDTESTOPT_ROOT_SPAN_RESOURCE:
            # The root resource is handled by the pytest plugin.
            return

        event = Event(
            version=1,
            type="span",
            content={
                "trace_id": trace_id % (1 << 64),
                "parent_id": parent_id % (1 << 64) if parent_id is not None else None,
                "span_id": span_id % (1 << 64),
                "service": service,
                "resource": resource,
                "name": name,
                "error": error,
                "start": start_ns,
                "duration": duration_ns,
                "meta": meta,
                "metrics": metrics,
                "type": meta.get("type") or span_type,
            },
        )
        writer.put_event(event)

    tracer_interface_instance.enable_trace_collection(push_span)


def uninstall_global_trace_filter() -> None:
    """
    Uninstall trace filters from the global ddtrace tracer.
    """
    if not tracer_interface_instance:
        return

    tracer_interface_instance.disable_trace_collection()


@contextlib.contextmanager
def trace_context(ddtrace_enabled: bool) -> t.Generator[TestContext, None, None]:
    """
    Create a trace context for a test to run.

    If ddtrace is enabled, a ddtrace context will be started; any spans created inside the test (e.g., instrumented HTTP
    requests) will be children of this context. This context manager yields a `TestContext` object containing the
    trace_id and span_id of created context.

    If ddtrace is not enabled, yields a dummy context with a freshly generated trace_id and span_id.
    """
    if tracer_interface_instance and tracer_interface_instance.should_enable_trace_collection():
        with tracer_interface_instance.trace_context(DDTESTOPT_ROOT_SPAN_RESOURCE) as trace_context:
            yield TestContext(span_id=trace_context.span_id % (1 << 64), trace_id=trace_context.trace_id % (1 << 64))
    else:
        yield TestContext(trace_id=_gen_item_id(), span_id=_gen_item_id())
